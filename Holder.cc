// Copyright 2025 Fondazione LINKS

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

//     http://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "Holder.h"


//==============================================================================
// H_Init  -    Initialization of common random string and matrices 
// 
// Input:
// - num_idx_hid:   number of undisclosed attributes (hidden)
//
// Outputs: 
// - crs:           structure with the pair (crs_ISIS, crs_Com), generated by Hcrs
// - B_f:           random matrix B_f ∈ Z^(d×t)_q
// - seed_crs:      initial public seed for crs structure
// - attrs:         attributes
//==============================================================================
void H_Init(CRS2_t& crs, mat_zz_p& B_f, uint8_t* seed_crs, Vec<string>& attrs, const long &num_idx_hid)
{
    // NOTE: assuming that current modulus is q0 (not q_hat)
    ulong       i;
    string      randomStr;

    // Initialize a 32 byte (256 bit) public seed for common random string (crs) structure,
    // using the cryptographically strong pseudo-random number generator from NTL
    RandomStream& RS = GetCurrentRandomStream();
    RS.get(reinterpret_cast<unsigned char*>(seed_crs), SEED_LEN);
    // for(i=0; i<SEED_LEN; i++)
    // {
    //     printf("%0x", seed_crs[i]);
    // }
    // printf("\n");
    
    // Generation of crs structure, using H_crs custom Hash function     
    Hcrs(crs, B_f, seed_crs, num_idx_hid);
    // NOTE: crs contains 3D uniformly random matrices mod q_hat,
    //       B_f is also generated from seed_crs

    // Initialize dummy attributes
    attrs.SetLength(l0);
    randomStr = to_string( RandomBnd(12345678) );

    for(i=0; i<l0; i++)
    {
        attrs[i] = to_string(i+1) + "-" + randomStr;
        // NOTE: dummy attributes (l0 = 8)
    }

    // return(crs, B_f, seed_crs, attrs)        
}


//==============================================================================
// H_VerCred1   -   Holder.VerCred1 function
// 
// Inputs:
// - seed_crs:      initial public seed for crs structure
// - crs:           structure with the pair (crs_ISIS, crs_Com), generated by Hcrs
// - ipk_bytes:     serialized Issuer Public Key
// - attrs:         attributes
// - idx_pub:       indexes of disclosed attributes (revealed)
// 
// Outputs:
// - Rho1:          structure ρ_1 that contains the commitment u and proof π
// - state:         structure that contains the polynomial vectors m and r
//==============================================================================
void H_VerCred1(RHO1_t& Rho1, STATE_t& state, const uint8_t* seed_crs, const CRS2_t& crs, const uint8_t* ipk_bytes, Vec<string>& attrs, const vec_UL &idx_pub)
{
    // NOTE: assuming that current modulus is q0 (not q_hat)
    ulong           i, j, k;
    IPK_t           ipk;
    vec_ZZX         mex, r;
    vec_ZZ          m_i, coeffs_m, coeffs_r, s;
    zz_pX           u;
    mat_zz_p        P0, P1, P; 
    vec_zz_p        u_vect, prod;
    ZZ              range, B_goth2;
    long            mul;
    size_t          len_u;

    const vec_UL    idx_hid = Compute_idx_hid(idx_pub); // Indexes of undisclosed attributes (hidden)
    const ulong     idxhlrd = (idx_hid.length() * h0) + (lr0 * d0); //|idx_hid|·h + ℓr·d
    const int       nbits   = ceil(log2(conv<double>(q0-1)));
       
    // 1. (a_1, ... , a_l) ← attrs,  a_i ∈ {0, 1}∗
    // NOTE: l0 = |idx_hid| + |idx_pub| = len(attrs),  d0 must divide l0*h0

    #ifdef USE_REVOCATION
            
        // If necessary, WAIT until the next integer minute for demonstration purposes
        Wait_till_next_min(0, 10);
        // NOTE: avoid to request a credential that will expire in next 10 seconds

        // Get the timestamp for the current date/time and update the corresponding attribute
        attrs[IDX_TIMESTAMP] = Get_timestamp(1);

    #endif

    
    // 2. (c0, c1) ← ipk,   (c0, c1) ∈ R^ℓm_q × R^ℓr_q
    CompleteIPK(ipk, ipk_bytes);
    

    // 3. m ← Coeffs^−1( H_M(a1), ... , H_M(a_l) ) ∈ R^ℓm
    mex.SetLength(lm0);    
    coeffs_m.SetLength(l0 * h0);
    k = 0;

    for(i=0; i<l0; i++)
    {                  
        // a_i = attrs[i];        
        HM(m_i, attrs[i] );        

        for(j=0; j<h0; j++)     
        {
            coeffs_m[k] = m_i[j];
            k++;
        }
    }    

    CoeffsInvX(mex, coeffs_m, lm0);


    // 4. r ← S^ℓr_ψ,   r ∈ R^ℓr
    r.SetLength(lr0);   
    range = 2*psi0 + 1;
    
    for(i=0; i<lr0; i++)
    {
        r[i].SetLength(d0);
        
        for(j=0; j<d0; j++)     
        {
            r[i][j] = RandomBnd(range) - psi0;
            // NOTE: each coefficient is in the range [−psi0, psi0];
        }
    }


    // 5. u ← c0^T * m + c1^T * r ∈ R_q
    u.SetLength(d0);
    u = poly_mult(ipk.c0, conv<vec_zz_pX>(mex)) + poly_mult(ipk.c1, conv<vec_zz_pX>(r));


    // 6. P ← [rot(c0^T)_(idx_hid) | rot(c1^T)],    P ∈ Z_q^(d × (|idx_hid|·h + ℓr·d))   
    P.SetDims(d0, (idxhlrd + d_hat));
    // NOTE: zero padding of P (d_hat columns) anticipated here, from Preprocessing_Com

    P0.SetDims(d0, lm0*d0);    
    rot_vect(P0,  ipk.c0);

    // NOTE: only idx_hid*h0 columns of P0 (corresponding to undisclosed attributes) 
    //       are copied as first columns into P, while P1 is fully copied into P.
    k = 0;

    for(auto &idx: idx_hid)
    {
        for(j=(idx*h0); j<((idx+1)*h0); j++)
        {
            for(i=0; i<d0; i++)
            {   
                P[i][k] = P0[i][j];
            }
            k++;
        }
    }
    
    P1.SetDims(d0, lr0*d0);
    rot_vect(P1, ipk.c1);    

    for(j=0; j<(lr0*d0); j++)
    {
        for(i=0; i<d0; i++)
        {   
            P[i][k] = P1[i][j];
        }
        k++;
    }

    P1.kill();
    
                
    // 7. s ← (Coeffs(m)_(idx_hid), Coeffs(r)),   s ∈ Z^(|idx_hid|·h + ℓr·d)
    s.SetLength(idxhlrd + d_hat);
    // NOTE: zero padding of s (d_hat values) anticipated here, from Preprocessing_Com
    
    coeffs_r.SetLength(lr0*d0);
    CoeffsX(coeffs_r, r, lr0);
    
    // NOTE: only idx_hid*h0 coeffs of m (corresponding to undisclosed attributes) 
    //       are copied into s, while coeffs of r is fully copied into s.
    k = 0;

    for(auto &idx: idx_hid)
    {
        for(j=(idx*h0); j<((idx+1)*h0); j++)
        {
            s[k] = coeffs_m[j];
            k++;
        }
    }

    for(j=0; j<(lr0*d0); j++)
    {
        s[k] = coeffs_r[j];
        k++;
    }


    // 8. u ← Coeffs(u) − rot(c0^T)_idx * Coeffs(m)_idx ∈ Z_q^d
    u_vect.SetLength(d0); 
    prod.SetLength(d0);
    
    // NOTE: only idx_pub*h0 columns of P0 and coeffs_m (corresponding to disclosed attributes) 
    //       are considered in the product rot(c0^T)_idx * Coeffs(m)_idx 
    for(j=0; j<d0; j++)
    {
        for(auto &idx: idx_pub)
        {
            for(k=(idx*h0); k<((idx+1)*h0); k++)
            {
                prod[j] += P0[j][k] * conv<zz_p>( coeffs_m[k] );
            }
        }
    }

    P0.kill();

    for(i=0; i<d0; i++)
    {
        // u_vect[i] = u[i] - prod[i];
        u_vect[i] = coeff(u, i) - prod[i];
    }


    // 9. π ← Prove_Com^HCom (crs_Com, (q1_hat/q·P, q1_hat/q·u_vect, ψ·sqrt(h·|idx_hid| + ℓr·d, s)
    if (not(divide( ZZ(q1_hat), q0)))
    {
        cout << " ERROR: q1_hat must be divisible by q! " << endl;
    }

    mul = long(q1_hat) / long(q0);

    // B_goth = psi0 * sqrt(conv<RR>( idxhlrd ));
    B_goth2 = sqr(ZZ(psi0)) * ZZ(idxhlrd); // B_goth^2

    {
        zz_pPush push(q1_hat); 
        // NOTE: backup current modulus q0, temporarily set to q1_hat (i.e., zz_p::init(q1_hat))
   
        Prove_Com(&(Rho1.Pi), seed_crs, crs[1], ipk.seed_ipk, (mul * P), (mul * u_vect), B_goth2, s, idx_hid);
        // NOTE: P, u_vect are converted from modulo q0 to q1_hat
        // NOTE: Prove_Com serializes the proof π in Rho1.Pi
    }

    P.kill();
   

    // 10. ρ_1 ← (u, π)

    // Allocate a vector of bytes to store u
    len_u = calc_ser_size_poly_minbyte(d0, nbits);
    Rho1.u = new uint8_t[len_u];
    // cout << "  Size u: " << (len_u/1024.0) << " KiB" << endl; // 1 KiB kibibyte = 1024 bytes
    
    // Serialize u in Rho1.u
    serialize_minbyte_poly_zz_pX(Rho1.u, len_u, d0, nbits, u);
    // Rho1.u += len_u;
    
          
    // 11. state ← (m, r) state ∈ R^ℓm × R^ℓr
    state.m = mex;
    state.r = r;
          
    // 12. return (ρ_1, state) 
}


//==============================================================================
// H_VerCred2   -   Holder.VerCred2 function
// 
// Inputs:
// - ipk_bytes:     serialized Issuer Public Key
// - B_f:           public random matrix B_f ∈ Z^(nd×t)_q
// - Rho2_ptr:      pointer to the structure ρ_2 = (s_0, w, x)
// - state:         structure that contains the polynomial vectors m and r
// 
// Outputs:
// - cred = (s,r,x): triple that corresponds to the credential
//==============================================================================
void H_VerCred2(CRED_t& cred, const uint8_t* ipk_bytes, const mat_zz_p& B_f, uint8_t** Rho2_ptr, const STATE_t& state)
{
    // NOTE: assuming that current modulus is q0 (not q_hat)
    ulong           i, j;
    IPK_t           ipk;
    vec_ZZ          s_0;
    vec_ZZX         w, s, mex;
    ZZ              x, norm_s, norm_r, th_s, th_r;
    zz_pX           left, right;
    vec_zz_pX       a;
    size_t          len_s0, len_w, len_x;
    uint8_t        *Rho2_bytes;

    // 1. (m, r) ← state,   state ∈ R^(ℓm) × R^(ℓr)
    mex = state.m;
    // r = state.r;

    #ifdef USE_REVOCATION

        ulong   k;
        vec_ZZ  m_i, coeffs_m;

        // Get the timestamp for the current date/time and use it instead of the corresponding attribute
        HM(m_i, Get_timestamp(1));
        // NOTE: i == IDX_TIMESTAMP

        // m ← Coeffs^−1( H_M(a1), ... , H_M(a_l) ) ∈ R^ℓm
        coeffs_m.SetLength(l0 * h0);    
        CoeffsX(coeffs_m, mex, lm0);
        k = IDX_TIMESTAMP * h0;

        for(j=0; j<h0; j++)     
        {
            coeffs_m[k] = m_i[j];
            k++;
        } 

        CoeffsInvX(mex, coeffs_m, lm0);

    #endif


    // 2. (a1, a2, c0, c1) ← ipk,   ipk ∈ R_q × R^m_q × R^(ℓm)_q × R^(ℓr)_q
    CompleteIPK(ipk, ipk_bytes);
    
    // 3. (s_0, w, x) ← ρ2,   ρ_2 ∈ Z^(2d) × R^m × N
    
    // Compute the number of bytes for each component of the structure ρ_2
    len_s0 = calc_ser_size_vec_ZZ(2*d0);    // vec_ZZ (2*d0*long)     -  8192 bytes
    len_w  = calc_ser_size_vec_ZZX(m0, d0); // vec_ZZX (m0*d0*long)   - 12288 bytes
    len_x  = calc_ser_size_big_ZZ(t0);      // big ZZ (t0 = 512 bits) -    64 bytes
    // size_t len_Rho2 = len_s0 + len_w + len_x; //                     20544 bytes
    // cout << "  Size Rho2: " << (len_Rho2/1024.0) << " KiB" << endl; // 1 KiB kibibyte = 1024 bytes
  
    // Deserialize the structure ρ_2
    Rho2_bytes = *Rho2_ptr;
    deserialize_vec_ZZ(s_0, 2*d0, Rho2_bytes, len_s0);
    Rho2_bytes+= len_s0;
    deserialize_vec_ZZX(w, m0, d0, Rho2_bytes, len_w);
    Rho2_bytes+= len_w;
    deserialize_big_ZZ(x, Rho2_bytes, len_x);
    x++;
    // Rho2_bytes+= len_x;

    // Free the vector with serialized structure ρ_2
    delete[] (*Rho2_ptr);


    // 4. s ← [Coeffs^(−1)(s_0) | w],   s ∈ R^(m+2)
    // NOTE: s_0 and s are different from s in Holder.VerCred1
    s.SetLength(m0+2);

    for(i=0; i<2; i++)
    {
        s[i].SetLength(d0);

        for(j=0; j<d0; j++)     
        {
            // s[i][j] =  s_0[d0*i + j] );
            SetCoeff(s[i], j, s_0[d0*i + j] );
        }        
    }     

    for(i=0; i<m0; i++)
    {
        s[i+2] = w[i];
    }
  
   
    // 5. if {∥s∥ > sigma0·√((m + 2)d))} ∨ {∥r∥ > ψ·√(ℓr·d)} ∨ {[1|a1|a2^T]*s != f(x) + c0^T*m + c1^T*r}
    // NOTE: equations in ZZ, with squared norms and thresholds
    norm_s = Norm2X(s, d0);
    th_s   = ZZ(sigma2) * ZZ( (m0+2)*d0 );

    norm_r = Norm2X(state.r, d0);
    th_r   = sqr(ZZ(psi0)) * ZZ( lr0*d0 );

    // a ← [1|a1|a2^T]
    a.SetLength(m0+2);
    
    a[0].SetLength(d0);
    a[0] = zz_pX(1); 

    a[1] =  ipk.a1;

    for(i=0; i<m0; i++)
    {
        a[2+i] =  ipk.a2[i];
    }

    // left ← [1|a1|a2^T] * s = a * s,   left ∈ R_q
    left = poly_mult(a, conv<vec_zz_pX>(s) );
    left.normalize();

    // right ← f(x) + c0^T * m + c1^T * r,   right ∈ R_q    
    right = Compute_f(B_f, x) + poly_mult( ipk.c0, conv<vec_zz_pX>(mex)) + poly_mult(ipk.c1, conv<vec_zz_pX>(state.r) );
    right.normalize();
    
    cred.valid = 0;

    // 5.1 if {∥s∥ > sigma0·√((m + 2)d))} 
    if (norm_s > th_s)
    {
        // 6.    return ⊥
        cout << "First  condition failed - Invalid s norm!" << endl;
        // cout << " norm_s = " << norm_s << " > " << th_s << endl;
        return;
    }
    
    // 5.2 ... or {∥r∥ > ψ·√(ℓr·d)} 
    else if (norm_r > th_r)
    {
        // 6.    return ⊥
        cout << "Second condition failed - Invalid r norm!" << endl;
        // cout << " norm_r = " << norm_r << " > " << th_r << endl;        
        return;               
    }

    // 5.3 ... or {[1|a1|a2^T]*s != f(x) + c0^T*m + c1^T*r}
    else if (left != right)
    {
        // 6.    return ⊥
        cout << "Third  condition failed - left != right!" << endl;
        // cout << " " << left << " != " << right << endl;        
        return; 
    }
    
    // 7. else
    else
    {
        // 8. cred ← (s, r, x),   (s, r, x) ∈ R^(m+2) × R^(ℓr) × N
        cred.s = s;
        cred.r = state.r;
        cred.x = x;
        cred.valid = 1;
    }

    // 9. return cred    
}


//==============================================================================
// H_VerPres    -    Holder.VerPres function
// 
// Inputs:
// - cred = (s,r,x): triple that corresponds to the credential
// - seed_crs:       initial public seed for crs structure
// - crs:            structure with the pair (crs_ISIS, crs_Com), generated by Hcrs
// - ipk_bytes:      serialized Issuer Public Key
// - B_f:            public random matrix B_f ∈ Z^(nd×t)_q
// - attrs:          attributes 
// - idx_pub:        indexes of disclosed attributes (revealed)
//
// Output:
// - VP:             structure for the Verifiable Presentation
//==============================================================================
void H_VerPres(VP_t& VP, const CRED_t& cred, const uint8_t* seed_crs, const CRS2_t& crs, const uint8_t* ipk_bytes, const mat_zz_p& B_f, const Vec<string>& attrs, const vec_UL &idx_pub)
{
    // NOTE: assuming that current modulus is q0 (not q_hat)
    ulong           i, j, k;
    IPK_t           ipk;
    vec_zz_pX       a; 
    // vec_ZZX      mex;
    vec_ZZ          m_i, coeffs_m, coeffs_s, coeffs_r, r_vect, coeffs_u;
    vec_zz_p        coeffs_m_idx;
    mat_zz_p        P, C0, C1, C; 
    vec_ZZ          Bounds;
    Vec<vec_ZZ>     sig;
    long            mul, Pi_valid;

    const ulong     num_idx_pub = idx_pub.length(); // Number of disclosed attributes (revealed)
    const vec_UL    idx_hid = Compute_idx_hid(idx_pub); // Indexes of undisclosed attributes (hidden)
    const ulong     idxhlrd = (idx_hid.length() * h0) + (lr0 * d0); //|idx_hid|·h + ℓr·d
    const ulong     m2d     = (m0 + 2)*d0;    // (m+2)·d
    const ulong     lmlrd   = (lm0 + lr0)*d0; // (ℓm+ℓr)·d

       
    // 1. (a_1, ... , a_l) ← attrs,   a_i ∈ {0, 1}∗
    // NOTE: l0 = |idx_hid| + |idx_pub| = len(attrs),  d0 must divide l0*h0

    // 2. (a1, a2, c0, c1) ← ipk,   ipk ∈ R_q × R^m_q × R^(ℓm)_q × R^(ℓr)_q
    CompleteIPK(ipk, ipk_bytes);

    // 3. (s, r, x) ← cred,   cred ∈ R^(m+2) × R^(ℓr) × N
    if (cred.valid == 0)
    {
        cout << "\n Invalid credential!" << endl;
        return;
    }

      
    // 4. m ← Coeffs^−1( H_M(a1), ... , H_M(a_l) ) ∈ R^ℓm
    // mex.SetLength(lm0);    
    coeffs_m.SetLength(l0 * h0);
    k = 0;

    for(i=0; i<l0; i++)
    {                  
        #ifdef USE_REVOCATION
            if (i == IDX_TIMESTAMP)
            {
                // Get the timestamp for the current date/time and use it instead of the corresponding attribute
                HM(m_i, Get_timestamp(0));
            }
            else
        #endif
            {
                // a_i = attrs[i];
                HM(m_i, attrs[i]);
            }

        for(j=0; j<h0; j++)     
        {
            coeffs_m[k] = m_i[j];
            k++;
        }
    }    

    // mex = CoeffsInvX(coeffs_m, lm0);
    // NOTE: coeffs_m is directly used instead of mex

    
    // a ← [1|a1|a2^T]  
    a.SetLength(m0+2);
    
    a[0].SetLength(d0);
    a[0] = zz_pX(1);  
       
    a[1] =  ipk.a1;

    for(i=0; i<m0; i++)
    {
        a[2+i] = ipk.a2[i];
    } 
          
          
    // 5. P ← rot([1|a1|a2^T]) = rot(a),   P ∈ Z^(d×(m+2)d)_q      
    P.SetDims(d0, (m2d + d_hat)); 
    // NOTE: zero padding of P (d_hat columns) anticipated here, from Preprocessing_ISIS   
    rot_vect(P, a);
    

    // 6. C ← [rot(c0^T)_(idx_pub) | rot(c0^T)_(idx_hid) | rot(c1^T)],   C ∈ Z_q^(d × (ℓm+ℓr)d)
    C.SetDims(d0, (lmlrd + d_hat));
    // NOTE: zero padding of C (d_hat columns) anticipated here, from Preprocessing_ISIS

    C0.SetDims(d0, lm0*d0);
    rot_vect(C0,  ipk.c0);

    // NOTE: first copy in C the columns for disclosed attributes, then those for undisclosed attributes
    // NOTE: lm0*d0 = l0*h0 = (|idx_hid| + |idx_pub|) * h0
    k = 0;

    for(auto &idx: idx_pub)
    {
        for(j=(idx*h0); j<((idx+1)*h0); j++)
        {
            for(i=0; i<d0; i++)
            {   
                C[i][k] = C0[i][j];
            }
            k++;
        }
    }
   
    for(auto &idx: idx_hid)
    {
        for(j=(idx*h0); j<((idx+1)*h0); j++)
        {
            for(i=0; i<d0; i++)
            {
                C[i][k] = C0[i][j];
            }
            k++;
        }
    }

    C0.kill();   

    C1.SetDims(d0, lr0*d0);  
    rot_vect(C1, ipk.c1);    

    for(j=0; j<(lr0*d0); j++)
    {
        for(i=0; i<d0; i++)
        {   
            C[i][k] = C1[i][j];
        }
        k++;
    }

    C1.kill(); 


    // 7. m ← Coeffs(m)_(idx_pub),   m ∈ Z_q^(idx_pub·h)
    coeffs_m_idx.SetLength(num_idx_pub * h0);
    k = 0;

    for(auto &idx: idx_pub)
    {
        for(i=(idx*h0); i<((idx+1)*h0); i++)
        {
            coeffs_m_idx[k] = conv<zz_p>(coeffs_m[i]);
            k++;
        }
    }


    // 8. s ← Coeffs(s),   s ∈ Z^((m+2)d)
    coeffs_s.SetLength(m2d + d_hat);
    // NOTE: zero padding of coeffs_s (d_hat values) anticipated here, from Preprocessing_ISIS
    CoeffsX(coeffs_s, cred.s, (m0+2));
    
    
    // 9. r ← (Coeffs(m)_(idx_hid), Coeffs(r)),   r ∈ Z^(|idx_hid|·h + ℓr·d)
    r_vect.SetLength(idxhlrd + d_hat);
    // NOTE: zero padding of r_vect (d_hat values) anticipated here, from Preprocessing_ISIS
    
    coeffs_r.SetLength(lr0*d0);    
    CoeffsX(coeffs_r, cred.r, lr0);
    
    // NOTE: only idx_hid*h0 coeffs of m (corresponding to undisclosed attributes) 
    //       are copied into r_vect, while coeffs of r is fully copied into r_vect.
    k = 0;

    for(auto &idx: idx_hid)
    {
        for(j=(idx*h0); j<((idx+1)*h0); j++)
        {
            r_vect[k] = coeffs_m[j];
            k++;
        }
    }

    for(j=0; j<(lr0*d0); j++)
    {
        r_vect[k] = coeffs_r[j];
        k++;
    }


    // 10. u ← enc(x) ∈ {0, 1}^t  
    // Compute enc(x), the binary decomposition of (x−1) 
    coeffs_u.SetLength(t0);

    for(i=0; i<t0; i++)
    {
        coeffs_u[i] = bit(cred.x-1, i);
    }
    

    // 11. Bounds ← ( sigma0·√((m + 2)d), ψ·√(h·|idx| + ℓr·d) ),    Bounds ∈ Z^2
    Bounds.SetLength(2);
    Bounds[0] = ZZ(sigma2) * ZZ((m0+2)*d0);
    Bounds[1] = sqr(ZZ(psi0)) * ZZ(idxhlrd);
    // NOTE: squared Bounds, values in ZZ

      
    // 12. VP ← emptyVP()
    // NOTE: see VP_t

    // 13. VP.cp ← VC.cp
    // VP.cp = VC.cp;

    // 14. VP.ipk ← VC.ipk
    VP.ipk_bytes = ipk_bytes;

    // 15. VP.attrs′ ← (attrs_{idx_pub} | {0}_{idx_hid})
    VP.attrs_prime = attrs; 
    // NOTE: select only disclosed attributes and fill with zeros for each i ∈ idx_hid 
    for(auto &i: idx_hid)
    {
        VP.attrs_prime[i] = "0"; // Zero padding
    }
    // cout << "  attrs  = " << attrs << endl;
    // cout << "  attrs' = " << VP.attrs_prime << endl;


    // 16. VP.idx ← idx
    // VP.idx = idx_pub;
         
        
    // 17. VP.pi ← Prove^HISIS_ISIS( crs_ISIS, ˆq2/q · P, ˆq2/q · C, m, ˆq2/q · B_f, Bounds, idx), (s, r, u) )
    if (not(divide( ZZ(q2_hat), q0)))
    {
        cout << " ERROR: q2_hat must be divisible by q! " << endl;
    }  

    mul = long(q2_hat) / long(q0);

    sig.SetLength(3);
    sig[0] = coeffs_s;
    sig[1] = r_vect;
    sig[2] = coeffs_u;

    {
        zz_pPush push(q2_hat);
        // NOTE: backup current modulus q0, temporarily set to q2_hat (i.e., zz_p::init(q2_hat)) 
    
        Prove_ISIS(&(VP.Pi), seed_crs, crs[0], ipk_bytes, (mul * P), (mul * C), coeffs_m_idx, (mul * B_f), Bounds, num_idx_pub, sig, idx_hid);
        // NOTE: P, C, B_f are converted from modulo q0 to q2_hat
    }

    P.kill();
    C.kill();
    
    Pi_valid = VP.Pi[0];

    // 18. return VP  
    if (Pi_valid)
    {
        VP.valid = 1;
    }
    else
    {
        VP.valid = 0;
    }
}



//==============================================================================
// H_VerCred_Plain - Holder.VerCred function for Plaintext VC
// 
// Inputs:
// - ipk_bytes:     serialized Issuer Public Key
// - B_f:           public random matrix B_f ∈ Z^(nd×t)_q
// - Rho_ptr:       pointer to the structure ρ = (s_0, w, x, r)
// - attrs:         attributes
// 
// Outputs:
// - cred = (s,r,x): triple that corresponds to the credential
//==============================================================================
void H_VerCred_Plain(CRED_t& cred, const uint8_t* ipk_bytes, const mat_zz_p& B_f, uint8_t** Rho_ptr, const Vec<string>& attrs)
{
    // NOTE: assuming that current modulus is q0 (not q_hat)
    ulong           i, j, k;
    IPK_t           ipk;
    vec_ZZ          s_0, m_i, coeffs_m;
    vec_ZZX         w, s, mex, r;
    ZZ              x, norm_s, norm_r, th_s, th_r;
    zz_pX           left, right;
    vec_zz_pX       a;
    size_t          len_s0, len_w, len_x, len_r;
    uint8_t        *Rho_bytes;
    
    // 1. (a1, a2, c0, c1) ← ipk,   ipk ∈ R_q × R^m_q × R^(ℓm)_q × R^(ℓr)_q
    CompleteIPK(ipk, ipk_bytes);
    
    // 2. (s_0, w, x, r) ← ρ,       ρ ∈ Z^(2d) × R^m × N × R^ℓr
    
    // Compute the number of bytes for each component of the structure ρ
    len_s0  = calc_ser_size_vec_ZZ(2*d0);    // vec_ZZ (2*d0*long)     -  8192 bytes
    len_w   = calc_ser_size_vec_ZZX(m0, d0); // vec_ZZX (m0*d0*long)   - 12288 bytes
    len_x   = calc_ser_size_big_ZZ(t0);      // big ZZ (t0 = 512 bits) -    64 bytes
    len_r   = calc_ser_size_vec_ZZX(lr0, d0);// vec_ZZX (lr0*d0*long)  -  8192 bytes
    // size_t len_Rho = len_s0 + len_w + len_x + len_r;//                28736 bytes
    // cout << "  Size Rho: " << (len_Rho/1024.0) << " KiB" << endl; // 1 KiB kibibyte = 1024 bytes
  
    // Deserialize the structure ρ
    Rho_bytes = *Rho_ptr;
    deserialize_vec_ZZ(s_0, 2*d0, Rho_bytes, len_s0);
    Rho_bytes+= len_s0;
    deserialize_vec_ZZX(w, m0, d0, Rho_bytes, len_w);
    Rho_bytes+= len_w;
    deserialize_big_ZZ(x, Rho_bytes, len_x);
    x++;
    Rho_bytes+= len_x;
    deserialize_vec_ZZX(r, lr0, d0, Rho_bytes, len_r);
    // Rho_bytes+= len_r;

    // Free the vector with serialized structure ρ
    delete[] (*Rho_ptr);

    
    // 3. (a_1, ... , a_l) ← attrs,  a_i ∈ {0, 1}∗


    // 4. m ← Coeffs^−1( H_M(a1), ... , H_M(a_l) ) ∈ R^ℓm
    mex.SetLength(lm0);
    coeffs_m.SetLength(l0 * h0);
    k = 0;

    for(i=0; i<l0; i++)
    {                  
        #ifdef USE_REVOCATION
            if (i == IDX_TIMESTAMP)
            {
                // Get the timestamp for the current date/time and use it instead of the corresponding attribute
                HM(m_i, Get_timestamp(1));
            }
            else
        #endif
            {
                // a_i = attrs[i];
                HM(m_i, attrs[i]);
            }

        for(j=0; j<h0; j++)     
        {
            coeffs_m[k] = m_i[j];
            k++;
        }
    }    

    CoeffsInvX(mex, coeffs_m, lm0);


    // 5. s ← [Coeffs^(−1)(s_0) | w],   s ∈ R^(m+2)
    // NOTE: s_0 and s are different from s in Holder.VerCred1
    s.SetLength(m0+2);

    for(i=0; i<2; i++)
    {
        s[i].SetLength(d0);

        for(j=0; j<d0; j++)     
        {
            // s[i][j] =  s_0[d0*i + j] );
            SetCoeff(s[i], j, s_0[d0*i + j] );
        }        
    }     

    for(i=0; i<m0; i++)
    {
        s[i+2] = w[i];
    }


    // 6. if {∥s∥ > sigma0·√((m + 2)d))} ∨ {∥r∥ > ψ·√(ℓr·d)} ∨ {[1|a1|a2^T]*s != f(x) + c0^T*m + c1^T*r}
    // NOTE: equations in ZZ, with squared norms and thresholds
    norm_s = Norm2X(s, d0);
    th_s   = ZZ(sigma2) * ZZ( (m0+2)*d0 );

    norm_r = Norm2X(r, d0);
    th_r   = sqr(ZZ(psi0)) * ZZ( lr0*d0 );

    // a ← [1|a1|a2^T]
    a.SetLength(m0+2);
    
    a[0].SetLength(d0);
    a[0] = zz_pX(1); 

    a[1] =  ipk.a1;

    for(i=0; i<m0; i++)
    {
        a[2+i] =  ipk.a2[i];
    }

    // left ← [1|a1|a2^T] * s = a * s,   left ∈ R_q
    left = poly_mult(a, conv<vec_zz_pX>(s) );
    left.normalize();

    // right ← f(x) + c0^T * m + c1^T * r,   right ∈ R_q    
    right = Compute_f(B_f, x) + poly_mult(ipk.c0, conv<vec_zz_pX>(mex)) + poly_mult(ipk.c1, conv<vec_zz_pX>(r));
    right.normalize();
    
    cred.valid = 0;

    // 6.1 if {∥s∥ > sigma0·√((m + 2)d))} 
    if (norm_s > th_s)
    {
        // 7.    return ⊥
        cout << "First  condition failed - Invalid s norm!" << endl;
        // cout << " norm_s = " << norm_s << " > " << th_s << endl;
        return;
    }
    
    // 6.2 ... or {∥r∥ > ψ·√(ℓr·d)} 
    else if (norm_r > th_r)
    {
        // 7.    return ⊥
        cout << "Second condition failed - Invalid r norm!" << endl;
        // cout << " norm_r = " << norm_r << " > " << th_r << endl;        
        return;               
    }

    // 6.3 ... or {[1|a1|a2^T]*s != f(x) + c0^T*m + c1^T*r}
    else if (left != right)
    {
        // 7.    return ⊥
        cout << "Third  condition failed - left != right!" << endl;
        // cout << " " << left << " != " << right << endl;        
        return; 
    }
    
    // 8. else
    else
    {
        // 9. cred ← (s, r, x),   (s, r, x) ∈ R^(m+2) × R^(ℓr) × N
        cred.s = s;
        cred.r = r;
        cred.x = x;
        cred.valid = 1;
    }

    // 10. return cred
}


#ifdef USE_REVOCATION
//==============================================================================
// H_ReqUpdate   -  Modified Holder.VerCred1 function, to request an updated VC
// 
// Inputs:
// - state:         structure that contains the polynomial vectors m and r
// - attrs:         attributes
// - ipk_bytes:     serialized Issuer Public Key
// 
// Outputs:
// - u_ptr:         pointer to the serialized commitment u (with old_timestamp)
// - old_timestamp: old timestamp (expired)
// - new_timestamp: updated timestamp (current date/time)
// - state:         structure with updated m
// - attrs:         attributes with updated timestamp
//==============================================================================
void H_ReqUpdate(uint8_t** u_ptr, string& old_timestamp, string& new_timestamp, STATE_t& state, Vec<string>& attrs, const uint8_t* ipk_bytes)
{
    // NOTE: assuming that current modulus is q0 (not q_hat)
    ulong           i, j, k;
    IPK_t           ipk;
    vec_ZZX         mex, r;
    vec_ZZ          m_i, coeffs_m;
    zz_pX           u;
    size_t          len_u;

    const int       nbits   = ceil(log2(conv<double>(q0-1)));
       
    // (a_1, ... , a_l) ← attrs,  a_i ∈ {0, 1}∗
    // NOTE: l0 = |idx_hid| + |idx_pub| = len(attrs),  d0 must divide l0*h0
    
    // (c0, c1) ← ipk,   (c0, c1) ∈ R^ℓm_q × R^ℓr_q
    CompleteIPK(ipk, ipk_bytes);
    

    // Retrieve m and r from state - m ∈ R^ℓm, r ∈ R^ℓr 
    mex.SetLength(lm0);
    r.SetLength(lr0);
    mex = state.m;
    r   = state.r;


    // Compute u ← c0^T * m + c1^T * r ∈ R_q  (with old_timestamp)
    u.SetLength(d0);
    u = poly_mult(ipk.c0, conv<vec_zz_pX>(mex)) + poly_mult(ipk.c1, conv<vec_zz_pX>(r));
  

    // Allocate a vector of bytes to store u
    len_u = calc_ser_size_poly_minbyte(d0, nbits);
    *u_ptr = new uint8_t[len_u];
    cout << "  Size u: " << (len_u/1024.0) << " KiB" << endl; // 1 KiB kibibyte = 1024 bytes
    
    // Serialize u
    serialize_minbyte_poly_zz_pX(*u_ptr, len_u, d0, nbits, u);
    
    
    // If necessary, WAIT until the next integer minute for demonstration purposes
    Wait_till_next_min(0, 10);
    // NOTE: avoid to request a credential that will expire in next 10 seconds

    // Get the timestamp for the current date/time and update the corresponding attribute
    old_timestamp = attrs[IDX_TIMESTAMP];
    new_timestamp = Get_timestamp(1);
    attrs[IDX_TIMESTAMP] = new_timestamp;


    // Update m ← Coeffs^−1( H_M(a1), ... , H_M(a_l) ) ∈ R^ℓm
    coeffs_m.SetLength(l0 * h0);
    k = 0;

    for(i=0; i<l0; i++)
    {                  
        // a_i = attrs[i];        
        HM(m_i, attrs[i]);        

        for(j=0; j<h0; j++)     
        {
            coeffs_m[k] = m_i[j];
            k++;
        }
    }    

    CoeffsInvX(mex, coeffs_m, lm0);

    
    // Update m in state ← (m, r)  state ∈ R^ℓm × R^ℓr
    state.m = mex;

    // Return (u_ptr, old_timestamp, new_timestamp, state, attrs) 
}
#endif