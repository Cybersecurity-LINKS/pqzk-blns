#include "Verifier.h"


//==============================================================================
// V_Verify     -    Verifier.Verify function
// 
// Inputs:
// - VP:             structure with the Verifiable Presentation
// - inputStr:       string containing the initial seed for crs
// - crs:            structure with the pair (crs_ISIS, crs_Com), generated by Hcrs
// - B_f:            public random matrix B_f ∈ Z^(nd×t)_q
// 
// Output:
// -  1 or 0:        accept if π is valid, reject if the proof is invalid
//==============================================================================
int  V_Verify(const VP_t& VP, const string& inputStr, const CRS2_t& crs, const mat_zz_p& B_f)
{
    // NOTE: assuming that current modulus is q0 (not q_hat)
    
    unsigned int    i, j, k;
    int             out;
    zz_pX           a1;
    vec_zz_pX       a2, c0, c1, a; //mex;
    vec_ZZ          m_i, coeffs_m;
    mat_zz_p        A, P, C, C0, C1; 
    vec_zz_p        coeffs_m_idx;
    vec_ZZ          Bounds;
    ZZ              mul;

    const unsigned int  m2d     = (m0 + 2)*d0;    // (m+2)·d
    const unsigned int  lmlrd   = (lm0 + lr0)*d0; // (ℓm+ℓr)·d
    const unsigned int  idxhlrd = (idx_hid * h0) + (lr0 * d0); //|idx_hid|·h + ℓr·d

    
    // 1. (a′_1, ··· , a′_ℓ) ← attrs′,   a′_i ∈ {0, 1}∗
    // NOTE: l0 = idx_hid + idx_pub = len(attrs),  d0 must divide l0*h0
    // NOTE: for every variable of l0 elements, the first are the idx_hid elements, the last are the idx_pub elements

    
    // 2. (a1, a2, c0, c1) ← ipk,   ipk ∈ R_q × R^m_q × R^(ℓm)_q × R^(ℓr)_q
    a1 = VP.ipk.a1;
    a2 = VP.ipk.a2;
    c0 = VP.ipk.c0;
    c1 = VP.ipk.c1;

       
    // 3. m′ ← Coeffs^−1(H_M(a′_1), ... , H_M(a′_ℓ)) ∈ R^ℓm_q      
    // mex.SetLength(lm0);    
    coeffs_m.SetLength(l0 * h0);
    k = 0;

    for(i=0; i<l0; i++)
    {                  
        // a_i = VP.attrs_prime[i];        
        HM(m_i, VP.attrs_prime[i] );

        for(j=0; j<h0; j++)     
        {
            coeffs_m[k] = m_i[j];
            k++;
        }
    }    

    // mex = CoeffsInv(coeffs_m, lm0);
    // NOTE: coeffs_m is directly used instead of mex


    // a ← [1|a1|a2^T]  
    a.SetLength(m0+2);
    
    a[0].SetLength(d0);
    a[0] = zz_pX(1);  
       
    a[1] = a1;

    for(i=0; i<m0; i++)
    {
        a[2+i] = a2[i];
    } 
          
          
    // 4. P ← rot([1|a1|a2^T]) = rot(a),   P ∈ Z^(d×(m+2)d)_q
    A.SetDims(d0, m2d);
    P.SetDims(d0, (m2d + d_hat)); 
    // NOTE: zero padding of P (d_hat columns) anticipated here, from Verify_ISIS   
    
    rot_vect(A, a);
    
    for(i=0; i<d0; i++)
        {   
        for(j=0; j<m2d; j++)
        {
            P[i][j] = A[i][j];
        }
    }    

    A.kill();


    // 5. C ← [rot(c0^T)_(idx_pub) | rot(c0^T)_(idx_hid) | rot(c1^T)],   C ∈ Z_q^(d × (ℓm+ℓr)d)
    C.SetDims(d0, (lmlrd + d_hat));
    // NOTE: zero padding of C (d_hat columns) anticipated here, from Verify_ISIS

    C0.SetDims(d0, lm0*d0);
    rot_vect(C0, c0);

    // NOTE: first copy in C the columns for disclosed attributes, then those for undisclosed attributes
    // NOTE: lm0*d0 = l0*h0 = (idx_pub + idx_hid) * h0       
    k = 0;

    for(j=0; j<(idx_pub*h0); j++)
    {
        for(i=0; i<d0; i++)
        {   
            C[i][k] = C0[i][idx_hid*h0+j];
        }
        k++;
    }    

    for(j=0; j<(idx_hid*h0); j++)
    {
        for(i=0; i<d0; i++)
        {   
            C[i][k] = C0[i][j];
        }
        k++;
    }

    C0.kill(); 

    C1.SetDims(d0, lr0*d0);
    rot_vect(C1, c1);

    for(j=0; j<(lr0*d0); j++)
    {
        for(i=0; i<d0; i++)
        {   
            C[i][k] = C1[i][j];
        }
        k++;
    }

    C1.kill();

  
    // 6. m' ← Coeffs(m')_(idx_pub),   m' ∈ Z_q^(idx_pub·h)
    coeffs_m_idx.SetLength(idx_pub*h0);

    for(i=0; i<(idx_pub*h0); i++)
    {
        coeffs_m_idx[i] = conv<zz_p>(coeffs_m[(idx_hid*h0)+i]);
    }


    // 7. Bounds ← ( sigma0·√((m + 2)d), ψ·√(h·|idx| + ℓr·d) ),    Bounds ∈ Z^2
    Bounds.SetLength(2);
    // Bounds[0] = conv<RR>(sigma0) * sqrt(conv<RR>( (m0+2)*d0) );
    // Bounds[1] = psi0 * sqrt(conv<RR>( idxhlrd ));
    Bounds[0] = sqr( ZZ(sigma0) ) * ZZ( (m0+2)*d0 );
    Bounds[1] = sqr( ZZ(psi0)   ) * ZZ( idxhlrd   );


    // 8. return  Verify^HISIS_ISIS( crs_ISIS, (ˆq2/q·P, ˆq2/q·C, m′, ˆq2/q·Bf, Bounds, idx), VP.pi )
    if (not(divide( ZZ(q2_hat), q0)))
    {
        cout << " ERROR: q2_hat must be divisible by q! " << endl;
    }

    mul = ZZ(q2_hat)/q0;

    out = Verify_ISIS(inputStr, crs[0], VP.ipk, (mul * conv<mat_ZZ>(P)), (mul * conv<mat_ZZ>(C)), coeffs_m_idx, (mul * conv<mat_ZZ>(B_f)), Bounds, ZZ(idx_pub), VP.pi ); 
    // NOTE: P, C, B_f must be converted to ZZ, without modulo q0, to be properly passed as inputs to Verify_ISIS

    P.kill();
    C.kill();

    return out;
}
