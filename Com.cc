// Copyright 2025 Fondazione LINKS

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

//     http://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "Com.h"


//==============================================================================
// Preprocessing_Com -  Preprocessing function (PreprocessingProve^HCom_Com). 
//                      It takes as input (P, s, B_goth) with B_goth ≥ ||s||. 
//                      It returns s such that B_goth = ||s|| 
//                      and P filled with the appropriate number of zeros.
// 
// Inputs:
// - P:             matrix P  ∈ Z^[d x (|idx_hid|·h + ℓr·d)]_(q_hat)
// - s:             vector s  ∈ Z^(|idx_hid|·h + ℓr·d)_q_hat
// - B_goth2:       bound  B_goth^2 ∈ Z≥0 (it is a scalar)
//  
// Output:
// - P1:            matrix P1 ∈ Z^[d x (|idx_hid|·h + ℓr·d + d_hat]_(q_hat)
// - s0:            vector s0 ∈ Z^(|idx_hid|·h + ℓr·d + d_hat)_q_hat
//==============================================================================
// NOTE: zero padding of P already done in H_VerCred1
void  Preprocessing_Com(vec_ZZ& s0, const vec_ZZ& s, const ZZ& B_goth2)
{    
    // NOTE: assuming that current modulus is q1_hat (not q0)
    long    i;//j;
    ZZ      diff; //a1, a2, a3, a4;
    vec_ZZ  v;
    
    const long  idxhlrd = (idx_hid * h0) + (lr0 * d0); //|idx_hid|·h + ℓr·d
    
    // diff = B_goth^2 − ||s||^2
    diff = (B_goth2 - Norm2(s));
    
    if (diff < 0)
    {
        cout << "ERROR! (B_goth^2 - ||s||^2) must be positive: " << diff << endl;
        assert(diff >= 0);
    }
    else if (diff == 0)
    {
        cout << "WARNING! (B_goth^2 - ||s||^2) == 0 " << endl;
    }

    // diff = diff % q1_hat;
    // // NOTE: diff mod q1_hat, to speed up sum_of_four_squares


    // // 1. (a1, a2, a3, a4) ← SumOfFourSquares(B_goth^2 − ||s||^2),   (a1, a2, a3, a4) ∈ Z^4
    // sum_of_four_squares(a1, a2, a3, a4, diff);

    // // 2. a ← (a1, a2, a3, a4, 0, ... , 0),  a ∈ Z^(d_hat)
    // // NOTE: add d_hat − 4 zeros

    // 3. s0 ← (s, a),   s0 ∈ Z^(|idx_hid|·h + ℓr·d + d_hat)
    s0.SetLength(idxhlrd + d_hat);

    for(i=0; i<idxhlrd; i++)
    {
        s0[i] = s[i];
    }

    // s0[idxhlrd]   = a1;
    // s0[idxhlrd+1] = a2;
    // s0[idxhlrd+2] = a3;
    // s0[idxhlrd+3] = a4;

    // NOTE: sum_of_four_squares (too slow) replaced with fast_sum_of_squares
    fast_sum_of_squares(v, diff);
    
    for(i=0; i<v.length(); i++)
    {
        s0[idxhlrd+i] = v[i];
    }


    // 4. P1 ← [P,  0_(d × d_hat)],   P1 ∈ Z^[d x (|idx_hid|·h + ℓr·d + d_hat]_(q_hat)
    // P1.SetDims(d0, (idxhlrd + d_hat));

    // for(i=0; i<d0; i++)
    //     {   
    //     for(j=0; j<idxhlrd; j++)
    //     {
    //         P1[i][j] = P[i][j];
    //     }
    // }  

    // 5. return (P1, s0)
}


//==============================================================================
// Prove_Com   -    Computes the Commitment (Prove^HCom_Com). 
//                  This function takes as input crs, (P, u, B_goth), and w.
//                  If all the checks pass, it returns the proof π.
// 
// Inputs:
// - inputStr:      string containing the initial seed for crs
// - crs:           structure crs_Com, generated by Hcrs from inputStr
// - ipk:           Issuer public key
// - (P,u,B_goth2): this triplet corresponds to x, with:
//                  P ∈ Z^[d x (m1*d_hat)]_(q_hat)
//                  u ∈ Z^(d)_q_hat
//                  B_goth^2 ∈ Z≥0 (it is a scalar)
// - w0:            it contains the vector s ∈ Z^(m1*d_hat)_q_hat
//                  NOTE: (|idx_hid|*h + l_r*d + d_hat) == (m1 * d_hat)
//  
// Output:
// - Pi:            proof (π) structure 
//==============================================================================
void Prove_Com(PROOF_C_t& Pi, const string& inputStr, const CRS_t& crs, const IPK_t& ipk, const mat_zz_p& P, const vec_zz_p& u0, const ZZ& B_goth2, const vec_ZZ& w0)
{
    // NOTE: assuming that current modulus is q1_hat (not q0)

    unsigned long       i, j, k, idx;
    long                rst, b1, b2, b3, bbar1, bbar2;
    Mat<zz_pX>          B, D2;
    vec_zz_pX           u, s_1_mod, s_2_mod, g; //t_B;
    vec_zz_pX           h_part1, h_part2;
    vec_zz_pX           r_j, p_j, mu, m, s_hat, tmp_vec, y;
    vec_zz_pX           d_1, acc_vec, sigma_s_1, D2_y;
    vec_ZZX             s_1, s_2, y_1, y_2, y_3;
    vec_ZZX             c_s1, c_s2;
    zz_pX               h_part3, acc, sum, f1; //d_0, sum_sigma_e_u;
    ZZX                 c;
    RR                  alpha_i;
    Vec<vec_zz_pX>      e_, e_prime;
    Vec<vec_zz_pX>      sigma_r_, sigma_p_, sigma_e_, sigma_e_prime_;
    Vec<vec_ZZX>        st_1,  st_2;
    stringstream        ss;         
    mat_L               R_goth;
    vec_ZZ              s0, coeffs_y3, coeffs_R_goth_mult_s1; //coeffs_s1;
    mat_zz_p            gamma;
    vec_zz_p            e_tmp;
    // zz_p             sum_z3, B_goth_p;

    // Initialise constants    
    const unsigned long n           = n_Com;
    const unsigned long m1          = m1_Com;
    const unsigned long m2          = m2_Com;
    const unsigned long d_d_hat     = (d0/d_hat);
    const unsigned long n256        = (256/d_hat);
    const unsigned long m1_n256_tau = 2*m1 + 2*(n256 + tau0);

    // Initialise the "goth" constants
    const RR  B_goth = sqrt(conv<RR>(B_goth2));
    // s1_goth = alpha_1*nu0*B_goth
    // s2_goth = alpha_2*nu0*sqrt(m2*d_hat)
    // s3_goth = alpha_3*w_max(lambda0)*B_goth    
    const RR  s1_goth = RR(alpha_1 * nu0) * B_goth;
    const RR  s2_goth = RR(alpha_2 * nu0) * sqrt( RR(m2*d_hat) );
    const RR  s3_goth = RR(alpha_3 * w_max) * B_goth;
    const double s1_goth_d = conv<double>(s1_goth);
    const double s2_goth_d = conv<double>(s2_goth);
    const double s3_goth_d = conv<double>(s3_goth);
    
    // M1 := exp(sqrt(2(λ+1)/log e) * 1/α_1 + 1/2α_1^2
    // M2 := exp(sqrt(2(λ+1)/log e) * 1/α_2 + 1/2α_2^2
    // M3 := exp(sqrt(2(λ+1)/log e) * 1/α_3 + 1/2α_3^2    
    alpha_i = RR(alpha_1);
    const RR  M_1 = exp( sqrt( RR(2*(lambda0 + 1)) / log2e_Const ) * 1/alpha_i + 1/(2*sqr(alpha_i)));
    alpha_i = RR(alpha_2);
    const RR  M_2 = exp( sqrt( RR(2*(lambda0 + 1)) / log2e_Const ) * 1/alpha_i + 1/(2*sqr(alpha_i)));
    alpha_i = RR(alpha_3);
    const RR  M_3 = exp( sqrt( RR(2*(lambda0 + 1)) / log2e_Const ) * 1/alpha_i + 1/(2*sqr(alpha_i)));


    // 1. Retrieve from crs_Com
    // A_1     = crs[0];    // ∈ (R^_q^)^(n x m1)
    // A_2     = crs[1];    // ∈ (R^_q^)^(n x m2)
    // B_y     = crs[2];    // ∈ (R^_q^)^(256/d^ x m2)
    // B_g     = crs[3];    // ∈ (R^_q^)^(tau0 x m2)
    // b       = crs[4][0]; // ∈ (R^_q^)^(m2)         NOTE: b in crs is a (1 x m_2) matrix
    // Abar_1  = crs[5];    // ∈ (R^_q^)^(m1 x n1)
    // Abar_2  = crs[6];    // ∈ (R^_q^)^(m2 x n2)
    // Bbar_1  = crs[7];    // ∈ (R^_q^)^(m1 x n1)
    // Bbar_2  = crs[8];    // ∈ (R^_q^)^(m2 x n2)

    // 2. (P, u, B_goth) ← x
    // NOTE: directly provided as inputs
    
    // 3. s ← w
    // NOTE: combined with step 7 below
    
    // 4. (P, s) ← PreprocessingProve^HCom_Com (P, s, B_goth)
    // P ∈ Z^[d x (|idx_hid|·h + ℓr·d + d_hat]_(q_hat)
    // s ∈ Z^(|idx_hid|·h + ℓr·d + d_hat)    
    Preprocessing_Com(s0, w0, B_goth2);
              
    // 5. Initialize rst ∈ Z, scalar
    rst     = 0;

    // 6. Initialize idx ∈ N, scalar
    idx     = 0;

    // (3.) 7.1 Convert vector w (= s) into polynomial vector s_1 ∈ R^^(m1)
    CoeffsInvHatX(s_1, s0, m1);
    s_1_mod = conv<vec_zz_pX>( s_1 );    

    // 7.2 Convert vector u0 into polynomial vector u ∈ R^^(d/d_hat)_(q_hat) 
    CoeffsInvHat(u, u0, d_d_hat);


    // Initialize e ∈ R^^(256 x 256/d_hat)_(q_hat)
    e_.SetLength(256);    
    // NOTE: defined as e_ to distinguish it from the Euler constant e 

    e_tmp.SetLength(256);

    for(k=0; k<256; k++)
    {
        e_tmp[k] = 0;
    }

    for(j=0; j<256; j++)
    {
        // Temporary coefficient vector to create e_j: it is a unit vector with its j-th coefficient being 1
        e_tmp[j] = 1;        

        // e_[j].SetLength(n256);
        CoeffsInvHat(e_[j], e_tmp, n256);

        // Reset the e_tmp coefficient vector
        e_tmp[j] = 0;
    }    

    // Initialize e_prime ∈ R^^(d0 x d0/d_hat)_(q_hat)
    e_prime.SetLength(d0);
    e_tmp.SetLength(d0);

    for(k=0; k<d0; k++)
    {
        e_tmp[k] = 0;
    }

    for(j=0; j<d0; j++)
    {
        // Temporary coefficient vector to create e_j: it is a unit vector with its j-th coefficient being 1
        e_tmp[j] = 1;        

        // e_prime[j].SetLength(d_d_hat);
        CoeffsInvHat(e_prime[j], e_tmp, d_d_hat);

        // Reset the e_tmp coefficient vector
        e_tmp[j] = 0;
    }
   
    // Precompute σ(e_j), σ(p_j), σ(e′_j), σ(s_1), h_part2, h_part3
    sigma_e_.SetLength(256);
    sigma_p_.SetLength(d0);
    sigma_e_prime_.SetLength(d0);
    sigma_s_1.SetLength(m1);
    h_part2.SetLength(d0);
    
    for(j=0; j<256; j++)        
    {
        sigma_map(sigma_e_[j], e_[j], d_hat);  
    }       

    for(j=0; j<d0; j++)        
    {
        CoeffsInvHat(p_j, P[j], m1);
        sigma_map(sigma_p_[j], p_j, d_hat);
        sigma_map(sigma_e_prime_[j], e_prime[j], d_hat);   
        h_part2[j] = poly_mult_hat(sigma_p_[j], s_1_mod) - poly_mult_hat(sigma_e_prime_[j], u);
    }  

    sigma_map(sigma_s_1, s_1_mod, d_hat);
    h_part3   = poly_mult_hat(sigma_s_1, s_1_mod) + conv<zz_p>(-B_goth2);

    
    // 8. while (rst == 0 ∧ idx < N) do
    while((rst == 0) && (idx < N1))
    {
        b1 = 0; b2 = 0; b3 = 0;
        bbar1 = 0;   bbar2 = 0;
    
        // 9. Increment idx
        idx = idx + 1;
        // cout << "idx = " << idx << endl;
        
        // 10. Random generation of s_2 ∈ R^^(m2)
        s_2.SetLength(m2);

        for(i=0; i<m2; i++)
        {
            s_2[i].SetLength(d_hat);

            for(j=0; j<d_hat; j++)
            {
                s_2[i][j] = RandomBnd(3) - 1;
                // NOTE: uniform distribution on ternary polynomials chi, that sample coeffs from {-1,0,1}
            }
        }

        s_2_mod = conv<vec_zz_pX>( s_2 ); 


        // 11. t_A = A_1*s_1 + A_2*s_2,  tA ∈ R^^(n)_(q_hat)
        Pi.t_A.SetLength(n);
        acc.SetLength(d_hat);

        for(i=0; i<n; i++)
        {
            Pi.t_A[i].SetLength(d_hat);

            // acc = 0;
            clear(acc);     

            for(j=0; j<m1; j++)
            {
                acc += ModPhi_hat_q( crs[0][i][j] * s_1_mod[j] ); 
            }        

            for(j=0; j<m2; j++)
            {
                acc += ModPhi_hat_q( crs[1][i][j] * s_2_mod[j] ); 
            }  
            // NOTE: modulo q_hat on all coefficients (zz_pX)

            Pi.t_A[i] = acc;
        }
        
        // 12. Random generation of the y_1 ∈ R^^m1,  y_2 ∈ R^^m2,  y_3 ∈ R^^(256/d_hat)
        y_1.SetLength(m1);
        y_2.SetLength(m2);
        y_3.SetLength(n256);

        for(i=0; i<m1; i++)
        {
            y_1[i].SetLength(d_hat);

            for(j=0; j<d_hat; j++)
            {
                ZSampler(y_1[i][j], s1_goth_d, 0);
                // NOTE: implicitly sample the vector of coefficients and then convert it to a polynomial vector
            }
        }

        for(i=0; i<m2; i++)
        {
            y_2[i].SetLength(d_hat);

            for(j=0; j<d_hat; j++)
            {
                ZSampler(y_2[i][j], s2_goth_d, 0);
                // NOTE: implicitly sample the vector of coefficients and then convert it to a polynomial vector
            }
        }

        for(i=0; i<n256; i++)
        {
            y_3[i].SetLength(d_hat);

            for(j=0; j<d_hat; j++)
            {
                ZSampler(y_3[i][j], s3_goth_d, 0);
                // NOTE: implicitly sample the vector of coefficients and then convert it to a polynomial vector
            }
        }

        // 13. Random generation of g ∈ R^^(tau)_(q_hat)
        g.SetLength(tau0);

        for(i=0; i<tau0; i++)
        {
            g[i].SetLength(d_hat);
            g[i] = random_zz_pX(d_hat);            
            g[i][0] = 0;        
            // NOTE: the constant term of g (x^0) must be zero 
        }
    
        // 14. w = A1*y1 + A2*y2,  w ∈ R^^(n)_(q_hat)
        Pi.w.SetLength(n);
        // NOTE: it is different from the input w (= w0, from Prove_Init)
        acc.SetLength(d_hat);

        for(i=0; i<n; i++)
        {
            Pi.w[i].SetLength(d_hat);

            // acc = 0;
            clear(acc);              

            for(j=0; j<m1; j++)
            {
                acc += ModPhi_hat_q( crs[0][i][j] * conv<zz_pX>( y_1[j] ) ); 
            }        

            for(j=0; j<m2; j++)
            {
                acc += ModPhi_hat_q( crs[1][i][j] * conv<zz_pX>( y_2[j] ) ); 
            }                

            Pi.w[i] = acc;
            // NOTE: modulo q_hat on all coefficients (zz_pX)
        }

        // 15. t_y = B_y*s2 + y3,  t_y ∈ R^^(256/d_hat)_(q_hat)
        Pi.t_y.SetLength(n256);
        acc.SetLength(d_hat);

        for(i=0; i<n256; i++)
        {
            Pi.t_y[i].SetLength(d_hat);

            // acc = 0;
            clear(acc);

            for(j=0; j<m2; j++)        
            {
                acc += ModPhi_hat_q( crs[2][i][j] * s_2_mod[j] );
            }
                
            acc += conv<zz_pX>( y_3[i] );
                    
            Pi.t_y[i] = acc;
            // NOTE: modulo q_hat on all coefficients (zz_pX)
        }

        // 16. t_g = B_g*s2 + g,  t_g ∈ R^^(tau)_(q_hat)
        Pi.t_g.SetLength(tau0);
        acc.SetLength(d_hat);

        for(i=0; i<tau0; i++)
        {
            Pi.t_g[i].SetLength(d_hat);

            // acc = 0;
            clear(acc);               

            for(j=0; j<m2; j++)        
            {
                acc += ModPhi_hat_q( crs[3][i][j] * s_2_mod[j] );
            }
                
            acc += g[i];
            
            Pi.t_g[i] = acc;
            // NOTE: modulo q_hat on all coefficients (zz_pX)
        }
                                            
        // 17. (com_1, st_1) = LHC_Com(1, crs_LHC1, s_1, y_1)    
        LHC_Com(Pi.com_1, st_1, 1, crs[5], crs[7], s_1, y_1);

        // 18. (com_2, st_2) = LHC_Com(2, crs_LHC2, s_2, y_2)
        LHC_Com(Pi.com_2, st_2, 2, crs[6], crs[8], s_2, y_2);

        // 19. a1 ← (t_A, t_y, t_g, w, com_1, com_2) 
        ss.str("");    ss.clear();
        // ss << crs << P << u0 << B_goth2 << t_A << t_y << t_g << w << com_1 << com_2;
        ss << inputStr << ipk.c0 << ipk.c1 << u0 << B_goth2 << Pi.t_A << Pi.t_y << Pi.t_g << Pi.w << Pi.com_1 << Pi.com_2;
        // NOTE: using inputStr, ipk.c0, ipk.c1, instead of crs, P to speedup Hash_Init

        // 20. (R_goth_0, R_goth_1) = H(1, crs, x, a_1)
        // 21. R_goth = R_goth_0 - R_goth_1
        HCom1(R_goth, "1" + ss.str());
        // NOTE: R_goth ∈ {-1, 0, 1}^(256 x m_1*d_hat),
        //       equivalent to (R_goth_0 - R_goth_1) in BLNS

        // 22. coeffs_y3 ← Coeffs(y_3),   coeffs_y3 ∈ Z^(256)   
        CoeffsHat(coeffs_y3, y_3, n256);
        
        // 23.  z_3 = y_3 + R_goth*s,   z_3 ∈ Z^(256)   
        coeffs_R_goth_mult_s1.SetLength(256);
        Pi.z_3.SetLength(256);
        // NOTE: This equation is performed in Z not in polynomials, needing Coeffs() transformation of y_3, R_goth, and s_1

        for(i=0; i<256; i++)
        {
            coeffs_R_goth_mult_s1[i] = ( conv<vec_ZZ>(R_goth[i]) * s0 ); //coeffs_s1);
            // NOTE: this term corresponds to InnerProduct(result, coeffs_R_goth[i], coeffs_s1);

            Pi.z_3[i] = coeffs_y3[i] + coeffs_R_goth_mult_s1[i];
        }
        
        // 24. b3 ← Rej (z_3, R_goth * s, s3_goth, M_3),    b3 ∈ {0, 1}
        b3 = Rej_v_ZZ(Pi.z_3, coeffs_R_goth_mult_s1, s3_goth, M_3);
        
        // NOTE: if b3 == 0, continue the while loop (skip next rows until 53, then go to row 7)
        if (b3 == 0)
        {            
            rst = 0;
            continue;
        }
        
        // 25. a2 ← z_3,   a2 ∈ Z^256    
        ss << Pi.z_3;
        
        // 26. gamma ← H(2, crs, x, a1, a2),   gamma ∈ Z^(tau0 x 256+d0+1)_q_hat
        HCom2(gamma, "2" + ss.str());


        // Initialize h ∈ R^^(tau)_(q_hat)
        Pi.h.SetLength(tau0);    
        acc.SetLength(d_hat);
        clear(acc);

        // Precompute σ(r_j), h_part1
        sigma_r_.SetLength(256);  
        h_part1.SetLength(256); 

        for(j=0; j<256; j++)        
        {
            CoeffsInvHat(r_j,  conv<vec_zz_p>(R_goth[j]), m1 ); 
            sigma_map(sigma_r_[j], r_j, d_hat);  
            h_part1[j] = poly_mult_hat(sigma_r_[j], s_1_mod) + poly_mult_hat(sigma_e_[j], conv<vec_zz_pX>( y_3 )) + (conv<zz_p>( - Pi.z_3[j] ));
        }


        // 27. for i ∈ [τ] do
        for(i=0; i<tau0; i++) 
        {
            // 28. Compute h_i,   h_i ∈ R^_(q_hat)
            Pi.h[i].SetLength(d_hat);
            
            acc = g[i];

            for(j=0; j<256; j++)        
            {
                acc += gamma[i][j] * h_part1[j];
            }
                        
            for(j=0; j<d0; j++)        
            {
                acc += gamma[i][256+j] * h_part2[j];
            }
            
            acc += gamma[i][256+d0] * h_part3;
                    
            // 29. h ← (h_1, . . . , h_τ),   h ∈ R^^(tau)_(q_hat)
            Pi.h[i] = acc;
        }

        // 31. a_3 ← h,   a_3 ∈ R^^(tau)_(q_hat)    
        ss << Pi.h;

        // 32. μ ← H(3, crs, x, a1, a2, a3),   μ ∈ R^^(tau)_(q_hat)        
        HCom3(mu, "3" + ss.str());

        // 33. B   ← [B_y; B_g],   B ∈ R^^((256/d_hat + tau) x m2)_(q_hat)
        B.SetDims((n256 + tau0), m2);

        // 34. t_B ← [t_y; t_g],   t_B ∈ R^^(256/d_hat + tau)_(q_hat)
        // t_B.SetLength(n256 + tau0);
        // NOTE: t_B is unused in Prove_Com

        // 35. m   ← [y_3; g],     m ∈ R^^(256/d_hat + tau)_(q_hat)
        m.SetLength(n256 + tau0);

        for(i=0; i<n256; i++) 
        {
            B[i]   = crs[2][i];
            // t_B[i] = t_y[i];
            m[i]   = conv<zz_pX>( y_3[i] );
        }

        for(i=n256; i<(n256 + tau0); i++) 
        {
            B[i]   = crs[3][i-n256];
            // t_B[i] = t_g[i-n256];
            m[i]   = g[i-n256];
        }

        // 36. s_hat ← (s1; σ(s1); m; σ(m)),     s_hat ∈ R^^(2*m1 + 2*(256/d_hat + tau))_(q_hat)
        s_hat.SetLength( m1_n256_tau );
        for(i=0; i<m1; i++) 
        {
            s_hat[i] = s_1_mod[i];        
        }

        k = 0;

        for(i=m1; i<(2*m1); i++) 
        {
            s_hat[i] = sigma_s_1[k];  
            k++;      
        }

        k = 0;

        for(i=(2*m1); i<(2*m1 + n256 + tau0); i++) 
        {
            s_hat[i] = m[k];
            k++; 
        }

        sigma_map(tmp_vec, m, d_hat);
        k = 0;

        for(i=(2*m1 + n256 + tau0); i<(m1_n256_tau); i++)  
        {
            s_hat[i] = tmp_vec[k];    
            k++;    
        }
        
        // 37. y ← (y1; σ(y1); −B*y2; σ(-B*y2)),     y ∈ R^^(2*m1 + 2*(256/d_hat + tau))_(q_hat)
        y.SetLength( m1_n256_tau );

        for(i=0; i<m1; i++) 
        {
            y[i] = conv<zz_pX>( y_1[i] );        
        }

        sigma_map(tmp_vec, conv<vec_zz_pX>(y_1), d_hat);
        k = 0;

        for(i=m1; i<(2*m1); i++) 
        {
            y[i] = tmp_vec[k];  
            k++;      
        }
            
        // Compute B*y2 in a temporary vector
        tmp_vec.SetLength(n256 + tau0);
        acc.SetLength(d_hat);

        for(i=0; i<(n256 + tau0); i++)
        {
            tmp_vec[i].SetLength(d_hat);

            // acc = 0;
            clear(acc);

            for(j=0; j<m2; j++)        
            {
                acc += ModPhi_hat_q( B[i][j] * conv<zz_pX>( y_2[j] ) );
            }           
            
            tmp_vec[i] = acc;
            // NOTE: modulo q_hat on all coefficients (zz_pX)
        }
        
        k = 0;

        for(i=(2*m1); i<(2*m1 + n256 + tau0); i++) 
        {
            tmp_vec[k] = -tmp_vec[k]; // -B*y2
            y[i] = tmp_vec[k];        // -B*y2
            k++; 
        }

        sigma_map(tmp_vec, tmp_vec, d_hat);
        k = 0;

        for(i=(2*m1 + n256 + tau0); i<( m1_n256_tau ); i++) 
        {
            y[i] = tmp_vec[k]; // σ(-B*y2)
            k++;    
        }


        // 38. Definition of D_2_(2,1) ∈ R^^(m1 x m1)_(q_hat)           
        sum.SetLength(d_hat);
        // sum = 0;
        clear(sum);
                
        for(i=0; i<tau0; i++)
        {
            sum += ( mu[i] * gamma[i][256+d0] );           
        }
        // NOTE: removed D2_2_1, D2 matrix directly filled using sum
    
        
        // 39. Construction of D_2 ∈ R^^((2*m1+2(256/d_hat+τ))×(2*m1+2(256/d_hat+τ)))_(q_hat)
        D2.SetDims(m1_n256_tau, m1_n256_tau);    
        
        for(i=0; i<m1_n256_tau; i++)
        {
            for(j=0; j<m1_n256_tau; j++)        
            {
                D2[i][j].SetLength(d_hat);
            }
        }   
        
        for(i=0; i<m1; i++)
        {
            D2[m1 + i][i] = sum;
        }
        // NOTE: D2_2_1 in position (2,1), zeros in the rest
        

        // 40. Construction of d_1 ∈ R^^(2*m1+2(256/d_hat+τ))_(q_hat)
        d_1.SetLength(m1_n256_tau);

        for(i=0; i<m1_n256_tau; i++)
        {
            d_1[i].SetLength(d_hat);
            clear(d_1[i]);
        }    

        // 1st entry of d_1 (m1 polynomials)
        acc_vec.SetLength(m1);
        
        for(i=0; i<tau0; i++)
        {
            // Reset acc_vec
            for(j=0; j<m1; j++)
            {        
                acc_vec[j].SetLength(d_hat);
                
                // acc_vec[j] = 0;
                clear(acc_vec[j]);
            }               
                    
            for(j=0; j<256; j++)        
            {
                for(k=0; k<m1; k++)        
                {
                    acc_vec[k] += gamma[i][j] * sigma_r_[j][k];  
                }
            }

            for(j=0; j<d0; j++)        
            {
                for(k=0; k<m1; k++)        
                {                
                    acc_vec[k] += gamma[i][256+j] * sigma_p_[j][k];  
                }     
            }  
                        
            for(k=0; k<m1; k++)        
            {
                // Fill d_1 (first m1 polynomials) by accumulating mu[i]*(...sums...) 
                d_1[k] += ModPhi_hat_q( mu[i] * acc_vec[k]); 
            }               
        }

        // NOTE: skip 2nd entry of d_1 (m1 zeros)

        // 3rd entry of d_1 (256/d_hat polynomials)    
        acc_vec.SetLength(n256);
        
        for(i=0; i<tau0; i++)
        {
            // Reset acc_vec
            for(j=0; j<n256; j++)
            {        
                acc_vec[j].SetLength(d_hat); 

                // acc_vec[j] = 0;
                clear(acc_vec[j]);
            }                     
                    
            for(j=0; j<256; j++)        
            {
                for(k=0; k<n256; k++)        
                {
                    acc_vec[k] += gamma[i][j] * sigma_e_[j][k];  
                }          
            }        
                
            for(k=0; k<n256; k++)        
            {
                // Fill d_1 (256/d_hat polynomials) by accumulating mu[i]*(...sums...) 
                d_1[(2*m1)+k] += ModPhi_hat_q( mu[i] * acc_vec[k]);             
            }
        } 
        
        // 4th entry of d_1 (tau0 polynomials)    
        k = 0;

        for(i=(2*m1 + n256); i<(2*m1 + n256 + tau0); i++) 
        {
            d_1[i] = mu[k];
            k++;    
        }
        // NOTE: skip 5th entry of d_1 (256/d_hat + tau0 zeros)
        
        
        // // 41. Definition of d_0 ∈ R^_(q_hat)    
        // d_0.SetLength(d_hat);
        // clear(d_0);
        // // NOTE: d_0 (not d0 parameter) despite being in the pseudocode, it is not used in Prove_Com        
           
        // B_goth_p = conv<zz_p>(B_goth2);

        // for(i=0; i<tau0; i++)
        // {            
        //     sum_z3 = 0;
            
        //     for(j=0; j<256; j++)
        //     {
        //         sum_z3 += gamma[i][j] * conv<zz_p>(Pi.z_3[j]);
        //     }
                
        //     sum_sigma_e_u.SetLength(d_hat);
        //     clear(sum_sigma_e_u);
            
        //     for(j=0; j<d0; j++)
        //     {
        //         sum_sigma_e_u += gamma[i][256+j] * poly_mult_hat(sigma_e_prime_[j], u);        
        //     }
        
        //    d_0 = d_0 - ModPhi_hat_q( mu[i] * ( sum_z3 + sum_sigma_e_u + gamma[i][256+d0] * B_goth_p + Pi.h[i] )); 
        // }

        
        // 42. Definition of f1 ∈ R^_(q_hat)
        f1.SetLength(d_hat);
        clear(f1);

        // 1st addend of f1, (s_hat^T * D2 * y)
        acc_vec.SetLength(m1_n256_tau);

        // Compute  (D2 * y),  (2*m1 + 2*(256/d_hat + tau0)) polynomials
        for(i=0; i<m1_n256_tau; i++)    
        {
            acc_vec[i].SetLength(d_hat); 

            // acc_vec[i] = 0;
            clear(acc_vec[i]);

            acc_vec[i] = poly_mult_hat(D2[i], y);
        }

        // Accumulate  s_hat^T * (D2 * y)
        D2_y = acc_vec;
        f1 += poly_mult_hat(s_hat, acc_vec);

        // 2nd addend of f1,  (y^T * D2 * s_hat)
        acc_vec.SetLength(m1_n256_tau);

        // Compute  (D2 * s_hat),  (2*m1 + 2*(256/d_hat + tau0)) polynomials
        for(i=0; i<m1_n256_tau; i++)    
        {
            acc_vec[i].SetLength(d_hat); 

            // acc_vec[i] = 0;
            clear(acc_vec[i]);     

            acc_vec[i] = poly_mult_hat(D2[i], s_hat);
        }

        // Accumulate  y^T * (D2 * s_hat)    
        f1 += poly_mult_hat(y, acc_vec);

        // 3rd addend of f1,   (d_1^T * y)
        f1 += poly_mult_hat(d_1, y);


        // 43. Definition of f0 ∈ R^_(q_hat)
        Pi.f0.SetLength(d_hat);
        clear(Pi.f0);
        
        Pi.f0 = poly_mult_hat(y, D2_y) + poly_mult_hat(crs[4][0], conv<vec_zz_pX>(y_2));
        // NOTE: D2_y = (D2 * y) was already computed in row 41 (1st addend of f1) 
    
        
        // 44. Definition of t ∈ R^_(q_hat)
        Pi.t.SetLength(d_hat);
        clear(Pi.t);
        Pi.t = poly_mult_hat(crs[4][0], s_2_mod) + f1;

        // 45. a_4 ← (t, f0),   a_4 ∈ R^_(q_hat) x R^_(q_hat)  
        ss << Pi.t << Pi.f0;

        // 46. c ← H(4, crs, x, a1, a2, a3, a4),   c ∈ C ⊂ R^       
        HCom4(c, "4" + ss.str());


        // 47. for i ∈ {1, 2} do
        // NOTE: for simplicity, next operations are duplicated with suffixes _1 and _2

        // 48. z_i ← y_i + c*s_i,   z_i ∈ R^^(m_i)   
        Pi.z_1.SetLength(m1);
        Pi.z_2.SetLength(m2);

        c_s1.SetLength(m1);
        c_s2.SetLength(m2);
        
        for(i=0; i<m1; i++)
        {
            Pi.z_1[i].SetLength(d_hat);
            c_s1[i] = ModPhi_hat( c * s_1[i] );
            Pi.z_1[i]  = y_1[i] + c_s1[i]; 
        }
            
        for(i=0; i<m2; i++)
        {
            Pi.z_2[i].SetLength(d_hat);
            c_s2[i] = ModPhi_hat( c * s_2[i] );
            Pi.z_2[i]  = y_2[i] + c_s2[i]; 
        }
            

        // 49. b_i ← Rej(z_i, c*s_i, s_i_goth, M_i),   b_i ∈ {0, 1} 
        b1 = Rej_v_ZZX(Pi.z_1, c_s1, s1_goth, M_1);

        // NOTE: if b1 == 0, continue the while loop (skip next rows until 53, then go to row 7)
        if (b1 == 0)
        {            
            rst = 0;
            continue;
        }

        b2 = Rej_v_ZZX(Pi.z_2, c_s2, s2_goth, M_2); 

        // NOTE: if b2 == 0, continue the while loop (skip next rows until 53, then go to row 7)
        if (b2 == 0)
        {            
            rst = 0;
            continue;
        }


        // 50. op_i ← LHC.Open(i, c, st_i),    op_i ∈ {⊥} ∪ R^^(n_i) × R^^(m_i) × R^^(m_i)
        LHC_Open(Pi.op_1, 1, c, st_1);        

        // 51. if op_i = ⊥ then b_bar_i = 0
        if (Pi.op_1.length() == 0)
        {
            bbar1 = 0;
            // NOTE: if bbar1 == 0, continue the while loop (skip next rows until 53, then go to row 7)
            rst = 0;
            continue;
        }
        // 52. else b_bar_i = 1
        else
        {
            bbar1 = 1;
        }

        LHC_Open(Pi.op_2, 2, c, st_2);

        if (Pi.op_2.length() == 0)
        {
            bbar2 = 0;
        }
        else
        {
            bbar2 = 1;
        }    

        // 54. rst ← b1*b2*b3*b_bar_1*b_bar_2
        rst = b1*b2*b3*bbar1*bbar2;        
    
    } // End of while loop (row 7)


    // 55. if rst = 1 then return π
    if (rst == 1)
    {
        // 53. π ← (t_A, t_y, t_g, w, com_1, com_2, z_3, h, t, f0, z_1, z_2, op_1, op_2)    
        // Pi.t_A   = t_A;
        // Pi.t_y   = t_y;
        // Pi.t_g   = t_g;
        // Pi.w     = w;
        // Pi.com_1 = com_1;
        // Pi.com_2 = com_2;
        // Pi.z_3   = z_3;
        // Pi.h     = h;
        // Pi.t     = t;
        // Pi.f0    = f0;
        // Pi.z_1   = z_1;
        // Pi.z_2   = z_2;
        // Pi.op_1  = op_1;
        // Pi.op_2  = op_2;
        // NOTE: additional flag, to identify a valid proof
        Pi.valid = 1;
    }
    // 56. else return ⊥
    else // (rst == 0)      
    {
        // NOTE: invalid proof
        Pi.valid = 0;        
    }
    
    // return Pi;
}


//==============================================================================
// Verify_Com   -   Verify the Commitment (Verify^HCom_Com). 
//                  This function takes as input crs, (P, u, B_goth), and the proof π.
//                  It returns as output “reject” or “accept”.
// 
// Inputs:
// - inputStr:      string containing the initial seed for crs
// - crs:           structure crs_Com, generated by Hcrs from inputStr
// - ipk:           Issuer public key
// - (P,u,B_goth2): this triplet corresponds to x, with:
//                  P ∈ Z^[d x (m1*d_hat)]_(q_hat)
//                  u ∈ Z^(d)_q_hat
//                  B_goth^2 ∈ Z≥0 (it is a scalar)
// - Pi:            proof (π) structure 
//  
// Output:
// - 0 or 1:        reject or accept 
//==============================================================================
long Verify_Com(const string& inputStr, const CRS_t& crs, const IPK_t& ipk, const mat_zz_p& P, const vec_zz_p& u0, const ZZ& B_goth2, const PROOF_C_t& Pi)
{
    // NOTE: assuming that current modulus is q1_hat (not q0)

    unsigned long       i, j, k;
    long                b1, b2;
    Mat<zz_pX>          B, D2;
    vec_zz_pX           u, t_B, mu, z, tmp_vec, tmp_vec2, r_j, p_j;
    vec_zz_pX           d_1, acc_vec, z_1_mod, z_2_mod;
    ZZX                 c;
    zz_pX               c_mod, acc, sum, d_0, sum_sigma_e_u;
    Vec<vec_zz_pX>      e_ , e_prime;
    Vec<vec_zz_pX>      sigma_r_, sigma_p_, sigma_e_, sigma_e_prime_; 
    stringstream        ss;
    mat_L               R_goth;
    mat_zz_p            gamma;
    vec_zz_p            e_tmp;
    zz_p                sum_z3, B_goth_p;
    ZZ                  norm2_z1, norm2_z2, norm2_z3;  
    RR                  norm_z1, norm_z2, norm_z3;

    // Initialise constants and variables
    const unsigned long n           = n_Com;
    const unsigned long m1          = m1_Com;
    const unsigned long m2          = m2_Com;
    const unsigned long d_d_hat     = (d0/d_hat);
    const unsigned long n256        = (256/d_hat);
    const unsigned long m1_n256_tau = 2*m1 + 2*(n256 + tau0);

    // Initialise the "goth" constants
    const RR  B_goth  = sqrt(conv<RR>(B_goth2));
    const RR  s1_goth = RR(alpha_1 * nu0) * B_goth;
    const RR  s2_goth = RR(alpha_2 * nu0) * sqrt( RR(m2*d_hat) );
    const RR  s3_goth = RR(alpha_3 * w_max) * B_goth;
    const RR  B_goth_1 = s1_goth * sqrt( 2*m1*d_hat );
    const RR  B_goth_2 = s2_goth * sqrt( 2*m2*d_hat );
    const RR  B_goth_3 = 1.7 * s3_goth * sqrt( 256 );
             

    // 1. Retrieve from crs_Com
    // A_1     = crs[0];    // ∈ (R^_q^)^(n x m1)
    // A_2     = crs[1];    // ∈ (R^_q^)^(n x m2)
    // B_y     = crs[2];    // ∈ (R^_q^)^(256/d^ x m2)
    // B_g     = crs[3];    // ∈ (R^_q^)^(tau0 x m2)
    // b       = crs[4][0]; // ∈ (R^_q^)^(m2)         NOTE: b in crs is a (1 x m_2) matrix
    // Abar_1  = crs[5];    // ∈ (R^_q^)^(m1 x n1)
    // Abar_2  = crs[6];    // ∈ (R^_q^)^(m2 x n2)
    // Bbar_1  = crs[7];    // ∈ (R^_q^)^(m1 x n1)
    // Bbar_2  = crs[8];    // ∈ (R^_q^)^(m2 x n2)

    // 2. Retrieve (P, u, B_goth) ← x
    // NOTE: (P, u0, B_goth) already provided as inputs, so we just need to 
    //       convert u0 ∈ Z^(d)_q_hat  to  u ∈ R^^(d/d_hat)_(q_hat), needed at row 19
    CoeffsInvHat(u, u0, d_d_hat);

    // 3. P ← [P1,  0_(d × d_hat)],   P ∈ Z^[d x (|idx_hid|·h + ℓr·d + d_hat]_(q_hat)    
    // NOTE: zero padding of P already done in I_VerCred

    // 4. (t_A, t_y, t_g, w, com1, com2, z_3, h, t, f0, z_1, z_2, op1, op2) ← π       
    // Check if Pi contains a valid proof   
    if (Pi.valid != 1)
    {
        cout << "ERROR! Pi does not contain a valid proof" << endl;
        return 0;
    }
    // NOTE: to save memory, proof values will be directly accessed as Pi.{name},
    //       apart z_1 and z_2, that are often used modulo q1_hat      
    z_1_mod = conv<vec_zz_pX>( Pi.z_1 );
    z_2_mod = conv<vec_zz_pX>( Pi.z_2 );

    // 5. a1 ← (t_A, t_y, t_g, w, com_1, com_2) 
    // a_1 << Pi.t_A << Pi.t_y << Pi.t_g << Pi.w << Pi.com_1 << Pi.com_2;

    // 6. a2 ← z_3,   a2 ∈ Z^256    
    // a_2 << Pi.z_3;
    
    // 7. a_3 ← h,   a_3 ∈ R^^(tau)_(q_hat)    
    // a_3 << Pi.h;
    
    // 8. a_4 ← (t, f0),   a_4 ∈ R^_(q_hat) x R^_(q_hat)  
    // a_4 << Pi.t << Pi.f0;

    // 9. (R_goth_0, R_goth_1) = H(1, crs, x, a_1)
    // ss << crs << P << u0 << B_goth2 << Pi.t_A << Pi.t_y << Pi.t_g << Pi.w << Pi.com_1 << Pi.com_2;
    ss << inputStr << ipk.c0 << ipk.c1 << u0 << B_goth2 << Pi.t_A << Pi.t_y << Pi.t_g << Pi.w << Pi.com_1 << Pi.com_2;
    // NOTE: using inputStr, ipk.c0, ipk.c1, instead of crs, P to speedup Hash_Init
    
    // 10. R_goth = R_goth_0 - R_goth_1
    HCom1(R_goth, "1" + ss.str());
    // NOTE: R_goth ∈ {-1, 0, 1}^(256 x m_1*d_hat),
    //       equivalent to (R_goth_0 - R_goth_1) in BLNS

    // 11. gamma ← H(2, crs, x, a1, a2),   gamma ∈ Z^(tau0 x 256+d0+1)_q_hat     
    ss << Pi.z_3;    
    HCom2(gamma, "2" + ss.str());

    // 12. μ ← H(3, crs, x, a1, a2, a3),   μ ∈ R^^(tau)_(q_hat)        
    ss << Pi.h;    
    HCom3(mu, "3" + ss.str());

    // 13. c ← H(4, crs, x, a1, a2, a3, a4),   c ∈ C ⊂ R^           
    ss << Pi.t << Pi.f0;       
    HCom4(c, "4" + ss.str());
    c_mod = conv<zz_pX>( c );

    // 14. B   ← [B_y; B_g],   B ∈ R^^((256/d_hat + tau) x m2)_(q_hat)
    B.SetDims((n256 + tau0), m2);

    // 15. t_B ← [t_y; t_g],   t_B ∈ R^^(256/d_hat + tau)_(q_hat)
    t_B.SetLength(n256 + tau0);

    for(i=0; i<n256; i++) 
    {
        B[i]   = crs[2][i];
        t_B[i] = Pi.t_y[i];
    }

    for(i=n256; i<(n256 + tau0); i++) 
    {
        B[i]   = crs[3][i-n256];
        t_B[i] = Pi.t_g[i-n256];
    }
    

    // 16. z ← (z_1; σ(z_1); (c*t_B − B*z_2); σ(c*t_B − B*z_2)),     z ∈ R^^(2*m1 + 2*(256/d_hat + tau))_(q_hat)
    z.SetLength( m1_n256_tau ); 

    for(i=0; i<m1; i++) 
    {
        z[i] = z_1_mod[i]; // z_1
    }

    sigma_map(tmp_vec, z_1_mod, d_hat);
    k = 0;

    for(i=m1; i<(2*m1); i++) 
    {
        z[i] = tmp_vec[k]; // σ(z_1)
        k++;      
    }

    // Compute (c*t_B − B*z_2) in a temporary vector
    tmp_vec.SetLength(n256 + tau0);
    acc.SetLength(d_hat);

    for(i=0; i<(n256 + tau0); i++)
    {
        tmp_vec[i].SetLength(d_hat);

        // acc = 0;
        clear(acc);

        // c*t_B
        acc = ModPhi_hat_q( c_mod * t_B[i] );

        // − B*z_2
        for(j=0; j<m2; j++)        
        {
            acc += ModPhi_hat_q(- B[i][j] * z_2_mod[j] );
        }           
        
        tmp_vec[i] = acc;
        // NOTE: modulo q_hat on all coefficients (zz_pX)
    }
    
    k = 0;

    for(i=(2*m1); i<(2*m1 + n256 + tau0); i++) 
    {
        z[i] = tmp_vec[k]; // (c*t_B − B*z_2)
        k++; 
    }

    // Compute σ(c*t_B − B*z_2) in a temporary vector
    sigma_map(tmp_vec2, tmp_vec, d_hat); 
    k = 0;

    for(i=(2*m1 + n256 + tau0); i<(m1_n256_tau); i++)  
    {
        z[i] = tmp_vec2[k]; // σ(c*t_B − B*z_2)   
        k++;    
    }


    // 17. Definition of D_2_(2,1) ∈ R^^(m1 x m1)_(q_hat)    
    sum.SetLength(d_hat);
    // sum = 0;
    clear(sum);
            
    for(i=0; i<tau0; i++)
    {
        sum += ( mu[i] * gamma[i][256+d0] );           
    }
    // NOTE: removed D2_2_1, D2 matrix directly filled using sum

    
    // 18. Construction of D_2 ∈ R^^((2*m1+2(256/d_hat+τ))×(2*m1+2(256/d_hat+τ)))_(q_hat)
    D2.SetDims(m1_n256_tau, m1_n256_tau);    
    
    for(i=0; i<m1_n256_tau; i++)
    {
        for(j=0; j<m1_n256_tau; j++)        
        {
            D2[i][j].SetLength(d_hat);
        }
    }   
    
    for(i=0; i<m1; i++)
    {
        D2[m1 + i][i] = sum;
    }
    // NOTE: D2_2_1 in position (2,1), zeros in the rest


    // Initialize e ∈ R^^(256 x 256/d_hat)_(q_hat)
    e_.SetLength(256);    
    // NOTE: defined as e_ to distinguish it from the Euler constant e 

    e_tmp.SetLength(256);

    for(k=0; k<256; k++)
    {
        e_tmp[k] = 0;
    }

    for(j=0; j<256; j++)
    {
        // Temporary coefficient vector to create e_j: it is a unit vector with its j-th coefficient being 1
        e_tmp[j] = 1;        

        // e_[j].SetLength(n256);
        CoeffsInvHat(e_[j], e_tmp, n256);

        // Reset the e_tmp coefficient vector
        e_tmp[j] = 0;
    }    

    // Initialize e_prime ∈ R^^(d0 x d0/d_hat)_(q_hat)
    e_prime.SetLength(d0);
    e_tmp.SetLength(d0);

    for(k=0; k<d0; k++)
    {
        e_tmp[k] = 0;
    }

    for(j=0; j<d0; j++)
    {
        // Temporary coefficient vector to create e_j: it is a unit vector with its j-th coefficient being 1
        e_tmp[j] = 1;        

        // e_prime[j].SetLength(d_d_hat);
        CoeffsInvHat(e_prime[j], e_tmp, d_d_hat);

        // Reset the e_tmp coefficient vector
        e_tmp[j] = 0;
    }
    
    // Precompute σ(r_j), σ(p_j), σ(e_j), σ(e′_j) 
    sigma_r_.SetLength(256);          
    sigma_e_.SetLength(256);
    sigma_p_.SetLength(d0);
    sigma_e_prime_.SetLength(d0);
    
    for(j=0; j<256; j++)        
    {
        CoeffsInvHat(r_j,  conv<vec_zz_p>(R_goth[j]), m1 );
        sigma_map(sigma_r_[j], r_j, d_hat);
        sigma_map(sigma_e_[j], e_[j], d_hat);  
    }

    for(j=0; j<d0; j++)        
    {
        CoeffsInvHat(p_j, P[j], m1);
        sigma_map(sigma_p_[j], p_j, d_hat);
        sigma_map(sigma_e_prime_[j], e_prime[j], d_hat);            
    }

    
    // 19. Construction of d_1 ∈ R^^(2*m1+2(256/d_hat+τ))_(q_hat)
    d_1.SetLength(m1_n256_tau);

    for(i=0; i<m1_n256_tau; i++)
    {
        d_1[i].SetLength(d_hat);
        clear(d_1[i]);
    }    

    // 1st entry of d_1 (m1 polynomials)
    acc_vec.SetLength(m1);
    
    for(i=0; i<tau0; i++)
    {
        // Reset acc_vec
        for(j=0; j<m1; j++)
        {        
            acc_vec[j].SetLength(d_hat);
            
            // acc_vec[j] = 0;
            clear(acc_vec[j]);
        }               
                
        for(j=0; j<256; j++)        
        {
            for(k=0; k<m1; k++)        
            {
                acc_vec[k] += gamma[i][j] * sigma_r_[j][k];  
            }
        }

        for(j=0; j<d0; j++)        
        {
            for(k=0; k<m1; k++)        
            {                
                acc_vec[k] += gamma[i][256+j] * sigma_p_[j][k];  
            }     
        }  
                    
        for(k=0; k<m1; k++)        
        {
            // Fill d_1 (first m1 polynomials) by accumulating mu[i]*(...sums...) 
            d_1[k] += ModPhi_hat_q( mu[i] * acc_vec[k]); 
        }               
    }

    // NOTE: skip 2nd entry of d_1 (m1 zeros)

    // 3rd entry of d_1 (256/d_hat polynomials)    
    acc_vec.SetLength(n256);
  
    for(i=0; i<tau0; i++)
    {
        // Reset acc_vec
        for(j=0; j<n256; j++)
        {        
            acc_vec[j].SetLength(d_hat); 

            // acc_vec[j] = 0;
            clear(acc_vec[j]);
        }                     
                
        for(j=0; j<256; j++)        
        {
            for(k=0; k<n256; k++)        
            {
                acc_vec[k] += gamma[i][j] * sigma_e_[j][k];  
            }          
        }        
            
        for(k=0; k<n256; k++)        
        {
            // Fill d_1 (256/d_hat polynomials) by accumulating mu[i]*(...sums...) 
            d_1[(2*m1)+k] += ModPhi_hat_q( mu[i] * acc_vec[k]);             
        }
    }
    
    // 4th entry of d_1 (tau0 polynomials)    
    k = 0;

    for(i=(2*m1 + n256); i<(2*m1 + n256 + tau0); i++) 
    {
        d_1[i] = mu[k];
        k++;    
    }
    // NOTE: skip 5th entry of d_1 (256/d_hat + tau0 zeros)


    // 20. Definition of d_0 ∈ R^_(q_hat)    
    d_0.SetLength(d_hat);
    clear(d_0);
    // NOTE: d_0, not d0 parameter

    B_goth_p = conv<zz_p>(B_goth2);

    for(i=0; i<tau0; i++)
    {            
        sum_z3 = 0;
        
        for(j=0; j<256; j++)
        {
            sum_z3 += gamma[i][j] * conv<zz_p>(Pi.z_3[j]);
        }
            
        sum_sigma_e_u.SetLength(d_hat);
        clear(sum_sigma_e_u);
        
        for(j=0; j<d0; j++)
        {
            sum_sigma_e_u += gamma[i][256+j] * poly_mult_hat(sigma_e_prime_[j], u);        
        }
    
        d_0 = d_0 - ModPhi_hat_q( mu[i] * ( sum_z3 + sum_sigma_e_u + gamma[i][256+d0] * B_goth_p + Pi.h[i] )); 
    }


    // 21.  if one of the 4 conditions below does not hold, then return 0
       
    // Compute ||z_i||, Euclidean norm of each z_i   
    norm_z1 = sqrt( conv<RR>( Norm2X(Pi.z_1, d_hat) ) );
    norm_z2 = sqrt( conv<RR>( Norm2X(Pi.z_2, d_hat) ) );
    norm_z3 = sqrt( conv<RR>( Norm2( Pi.z_3) ) );


    // 21.1 First condition: ||z_1|| ≤ B_goth_1, ||z_2|| ≤ B_goth_2, ||z_3|| ≤ B_goth_3
    // NOTE: equations in RR  
    if ( norm_z1 > B_goth_1)
    { 
        cout << "First condition failed - Invalid z_1 norm!" << endl; 
        return 0;
    }

    if ( norm_z2 > B_goth_2)
    { 
        cout << "First condition failed - Invalid z_2 norm!" << endl; 
        return 0;
    }

    if ( norm_z3 > B_goth_3)
    { 
        cout << "First condition failed - Invalid z_3 norm!" << endl; 
        return 0;
    }


    // 21.2 Second condition: h˜_i == 0 for i ∈ [τ] 
    // NOTE: equations in R^^_(q_hat)
    for(i=0; i<tau0; i++)
    {
        if ( coeff(Pi.h[i], 0) != 0 )
        {
            cout << "Second condition failed! \n  h = " << Pi.h << endl;
            return 0;
        }
    }


    // 21.3 Third condition: A_1*z_1 + A_2*z_2 == w + c*t_A 
    // NOTE: equations in R^^(n)_(q_hat)    
    tmp_vec.SetLength(n);
    tmp_vec2.SetLength(n);
    acc.SetLength(d_hat);

    for(i=0; i<n; i++)
    {
        tmp_vec[i].SetLength(d_hat);
        tmp_vec2[i].SetLength(d_hat);

        // acc = 0;
        clear(acc);  
        
        for(j=0; j<m1; j++)
        {
            acc += ModPhi_hat_q( crs[0][i][j] * z_1_mod[j] ); 
        }        

        for(j=0; j<m2; j++)
        {
            acc += ModPhi_hat_q( crs[1][i][j] * z_2_mod[j] ); 
        }  

        // A_1*z_1 + A_2*z_2
        tmp_vec[i] = acc;

        // w + c*t_A 
        tmp_vec2[i] = Pi.w[i] + ModPhi_hat_q( c_mod * Pi.t_A[i] );
    }

    if (tmp_vec != tmp_vec2)
    {
        cout << "Third condition failed!" << endl; 
        return 0;
    }


    // 21.4 Fourth condition: z^T*D2*z + c*d_1^T*z + c^2*d_0 − (c*t − b^T*z_2) == f0 
    // NOTE: equations in R^^_(q_hat)
    acc.SetLength(d_hat);
    // acc = 0;
    clear(acc);  

    // 1st addend (z^T * D2 * z)  
    // Compute  (D2 * z),  (2*m1 + 2*(256/d_hat + tau0)) polynomials
    acc_vec.SetLength(m1_n256_tau);
    
    for(i=0; i<m1_n256_tau; i++)    
    {
        acc_vec[i].SetLength(d_hat); 

        // acc_vec[i] = 0;
        clear(acc_vec[i]);

        acc_vec[i] = poly_mult_hat(D2[i], z);
    }

    // Accumulate  z^T * (D2 * z)    
    acc += poly_mult_hat(z, acc_vec); 
    
    // 2nd addend (c * d_1^T * z)   
    // Compute  (c * d_1^T),  (2*m1 + 2*(256/d_hat + tau0)) polynomials
    for(i=0; i<m1_n256_tau; i++)    
    {
        // acc_vec[i] = 0;
        clear(acc_vec[i]);

        acc_vec[i] = ModPhi_hat_q( c_mod * d_1[i] );
    }

    // Accumulate  (c * d_1^T) * z 
    acc += poly_mult_hat(acc_vec, z);   
    
    // 3rd addend (c^2 * d_0)
    acc += ModPhi_hat_q( ModPhi_hat_q( sqr(c_mod) ) * d_0 );
      
    // 4rd addend −(c*t − b^T * z_2)
    acc -= ( ModPhi_hat_q( c_mod * Pi.t ) - poly_mult_hat(crs[4][0], z_2_mod) );
    
    if (acc != Pi.f0)
    {
        cout << "Fourth condition failed!" << endl; 
        return 0;
    }
    

    // 21.5 Fifth condition: for i ∈ {1, 2}, LHC.Verify_i((A_i, B_i), (com_i, c), (z_i, op_i)) == 1
    b1 = LHC_Verify(1, crs[5], crs[7], Pi.com_1, c, Pi.z_1, Pi.op_1);
    b2 = LHC_Verify(2, crs[6], crs[8], Pi.com_2, c, Pi.z_2, Pi.op_2);
    
    if ((b1==0) || (b2==0))
    {
        cout << "Fifth condition failed!" << endl; 
        return 0; 
    }

    // cout << "# Verify_Com: OK!" << endl;


    // 22. else, return 1
    return 1;
}